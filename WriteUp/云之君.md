# 2021Moectf  WP

#### 云之君

> **一些废话**~~可以不用看~~
纯纯滴零基础\~本来想暑假学的，但是自己在网上搜了很多东西，看得迷迷糊糊，IDA也不会用，所以一直拖到了开学。~~本来觉得可能自己不是学这东西的料吧，~~ 后来dbt叫我去做题，~~骗我说密码都白给，~~ 于是我就去试着做了前三道，真的是历尽千辛万苦啊哈哈哈哈，起步真是太难了，不过做出来是真的对我有很大鼓励吧，在终端里看到flag真的是鸡冻的不行啊哈哈哈\~后来又开始学逆向 ~~从我做的题真的看不出来是学逆向的吧啊哈哈哈哈~~ ，同时继续做密码 ~~（主要还是dbt带）~~ ，现在总算是摸到了一点门槛吧，至少不会像暑假那样迷茫的什么方向都没有了，可以说dbt真的是在关键时刻拉了我一把吧。
还有，非常感谢树师傅（含树），学逆向的路上也给了我很大帮助。
还有帮助过我的每一位同学，你们都很可爱~
非常感谢~~对我这个大彩笔~~这么耐心温柔的大家\~

## content

> **Crypto**

- beginOfCrypto
- BabyMultiple
- LazyRSA
- PRintNewG
- NumberTheory-FeeeeeMa
- BBBBBBBackpack
- FesitelTripple
- NumberTheory-Powwwwwer
- NumberTheory-MyGrandson

> **Classical Cryptography**

- Augustine's Way
- OldButPopular
- Augustine's Way#2
- Ez Vigenere
- モンスターを縫う
- Ex Viginere?

> **Reverse**

- welcome_to_the_world_of_re
- EinfachRe
- Realezpy
- A_game
- clothes
- 大佬请喝coffee
- ez_Algorithm

> **Misc**

- find_me
- Homework
- Phone Call

> **Pwn**

- test_your_nc
- Int_overflow

---
---
---

## **Crypto**
> ***beginOfCrypto***
>> 看一下代码~
ord是把flag的每一个字符转成数字，map则是一个用来迭代的函数，也就是对flag里的每一个字符ord，list转成列表之后存进data列表里。之后的for循环把data列表里的数字取e的指数，并把结果存在cip列表里。
知道加密过程之后就很简单了\~我们只需要把cip取e的对数，然后转成字符输出就可以了~    ~~第一题真是很温柔呢~~

``` python
import math
cip=[2.178203880729008e+47, 1.6094870669615087e+48, 7.307059979368028e+43, 9.889030319346894e+42, 2.3886906014249767e+50, 1.9862648361376436e+44,
 2.6195173187490456e+53, 9.889030319346894e+42, 7.016735912097614e+20, 2.178203880729008e+47, 7.307059979368028e+43, 1.811239082889014e+41,
 1.6094870669615087e+48, 5.920972027664636e+47, 214643579785915.7, 3.6379709476087856e+42, 7.307059979368028e+43, 5.399227610580139e+44,
 3.989519570547194e+45, 5.920972027664636e+47, 1.811239082889014e+41, 3.5451311827611436e+52, 1.6094870669615087e+48, 6.493134255664421e+50,
 3.23274119108484e+49, 1.811239082889014e+41, 1.2523631708422093e+29, 3.23274119108484e+49, 3.5451311827611436e+52, 4.375039447261315e+48,
 2.3886906014249767e+50, 7.016735912097614e+20, 1.811239082889014e+41, 9.889030319346894e+42, 3.831008000716566e+22, 3.23274119108484e+49,
 1.4093490824269349e+22, 1.4093490824269349e+22, 3.23274119108484e+49, 1.9355760420357097e+54]
flag=[]
for i in range(len(cip)):
    flag.append(math.log(cip[i],math.e))
for i in flag:
    print(chr(int(i)),end='')
#moectf{c0me_on!begin_your_Crypt0_c4r33r}
```

> ***BabyMultiple***
>> 看代码，大概意思就是把flag用encode函数进行了一次加密。跟第一题一样，逆向去写解密脚本就好了\~   
 ~~不过由于懒得动脑子了，~~ 可以观察一下，这个题是属于单字符加密，也就是一个明文字符对应一个确定的密文字符，所以我们可以直接把所有字符的加密结果都打印出来，然后在里边找我们需要的字符就好了。
 这里我把所有字符的加密后结果放在cyberlist里。

``` python
table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'
cyberlist=list("a61WRMHCxsnid94ZUPKFAvqlgb72XSNIDytoje_50VQLGBwrmhc83YTOJEzupkf")
flag='g3AfJPOfHPOJFfJuf_AYux1JFx39'
for i in flag:
    j=cyberlist.index(i)
    print(table[j],end='')
#y0u_4r3_gr34t_47_Mu17ic4ti0n
```

> ***LazyRSA***
>> 一个简单的RSA加密
求(p-1)*(q-1)的逆元可以用gmpy2库的invert，然后pow一下就好了
~~by the way: 这两个库真难装······~~
``` python
from Crypto.Util.number import*
import gmpy2
p =  7049120988661090136959367990211624032671088374397430253722914704672269343351268486642692858477617370573493581346846411168539408811542592351582581576539221
q =  11595461299251293002401295606096202123601375776115430944343338141843770078346355504245510150744085418550473572002573306023521368183889972175846278163010889
c =  48425576447741107904942007362859939933300480519833273210397511573241220126734053813936424490872852942885069257318462762079636783871415500644717758273774268724488497979368196170897933989184449432995120246590652553995031347596620505647525475638040859263109628716173897321613612254357251120398449111747305089380
e = 0x10001
flag=pow(c,gmpy2.invert(e,(p-1)*(q-1)),p*q)
print(long_to_bytes(flag))
#moectf{w0w_yOU_Know_h0w_70_d3crypt_th3_RSA}
```
> ***PRintNewG***
>> ~~做的最痛苦的一道题······~~
观察一下代码，是要解一个方程组，假设flag是m0的话，那么就是要解如下方程组：
(am0+b)%n=m1
(am1+b)%n=m2
(am2+b)%n=m3
这里要了解一下乘法逆元的概念。
方程ax%n=1,那么求x就叫求a关于n的乘法逆元。
而对ay%n=m，求出a关于n的乘法逆元后再乘以m模n即可。
此处的b可以用两个方程组相减来消去b，得到如下两个方程：
a(m0-m1)%n=m2-m1
a(m2-m1)%n=m2-m3
那么就可以直接当成二元方程组求解即可。
``` python
from Crypto.Util.number import*
import gmpy2
n=164955381960104851576442781839629371483790790743830073857213053104860144345367
m1=67066424717605861916529090048670931008913194546199003522357504998012803616537
m2=14585402872351563180055857554749250191721167730349724393021149201170995608751
m3=68393939370424772490169906192546208899639826391163845848999554903218827210979

a=(gmpy2.invert(m2-m1,n))*(m3-m2)%n
m=((gmpy2.invert(a,n))*(m1-m2)+m1)%n
print(long_to_bytes(m))
#moectf{PR1nt_N3w_G_s0_e45y}
```
>***NumberTheory-FeeeeeMa***
>>~~虽然叫费马，但考的还是RSA\~~~
扔到kafu里分解一下n：
PRP617 = 19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531562041
PRP617 = 19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531561919
直接上手：
``` python
import gmpy2
from Crypto.Util.number import *
e = 0x10001
c=5883797662470459824355663245986072888499217007658131616834157815812099907584034205088255553387720712715657503553785084616903197734118992506040765948815581238738585159640841277023597023582148173041980600751980206228524475872232080917683822098342300418744639304147771013376863895727877847094151770079046205501266017838881847833528612089868825489776289686550273385136080255799772961155599801690997753649087689949021276549323525754963020408864310302166537661098308581259246052869844362142747080042122189010627048397501817473817946566885487595098504403459522534124404289032779842658407728856164570059823567667669076044563549721918886430160041337156249733571322684187916005175717585587552966989348534775572282369273898182367851689305440672199427492706130124832744127722533758962606513875787129378871099575729793745175327897215145024490319291830298017471555440811147903390803597635585696411407922981136489077349754222355529320548946411677051716584081079246752768224289803323109047467790868885987703125118276891234633889937243303027095375365791207055516900563280115276282761652663098154769929217653527103304045922204641545963828632051715956492613217136463227530538723452005224696385225174844198627387638874395654771260577791169209134146482
p=19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531562041
q=19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531561919
flag=pow(c,gmpy2.invert(e,(p-1)*(q-1)),p*q)
print(long_to_bytes(flag))
#moectf{y0u_c4n_e4s1ly_f4ctor_th3_N}
```

> BBBBBBBackpack
>> 不是很懂背包，这个题倒着依次乘一下加回去就好了。
~~我也不知道什么背包问题？？？~~
``` python
flag=0
backpack=[1, 3, 6, 23, 81, 199, 670, 1844, 5535, 19547, 75437, 259056, 974664, 2399609, 7304021, 18537736, 38733276, 143785607, 300890806, 778420517, 3112554961, 9955080778, 34625138877, 103531993246, 294207209833, 632363887456, 2341888528510, 8736224869982, 33727228149167, 113026240109398, 334534210335245, 754812282783351, 2871232541211362, 7147990367228081, 16813142520913249, 62232346665698392, 132813746566508109, 436969187287191174, 1371311321857557068, 3465499917202578303, 10761115866584374884, 25998484366411649657, 81986464388691181616, 324842980726420787162, 1063428202306999892763, 3318046410585817603032, 12569059003729082352479, 29822650425811094387624, 89829868596281155601134, 207467076929560545986692, 424101883375592006882573, 1410057940679583010646572, 4795250448769489602371933, 12419955465903295439689190, 32127052925660652338148413, 121768246803017981541739592, 286293639144639999224246905, 876618562849333372078886060, 3495370549956845610130431964, 13777448384830441398471073019, 45339968634224370226443992856, 159636974047457043534720001443, 403806399587759901542286515690, 1190949464093267805434271517577, 2625636206558220580206955200643, 5447410189447132699195152662348, 13798370097217657917056458399390, 42652195271813913821236091812630, 87624112365004035907264763291796, 295833079631922620770335225824586, 717255284196409248439771704866883, 2119024457898120787521595829459142, 8097762744600097674390735606807128, 22990496332708170421088808438995636, 55268619563994680834441597248247582, 157779112538179073738464223501777499, 553561084981889545670380643023607621, 2094594867042850711386606235023415160, 7427564397983932982484534762285032864, 28541899514275079822011638819911534081, 59854615377110931361953157015440306520, 137071568336121640486639449884477676903, 434368553369190183317274206512577489165, 1607515956833802196435755021284640023303, 4247439813046769661567823675143526066989, 12252982336388472725165513300377051313644, 43586970358791422986656986286232849952290, 94754002216262928157061686798919700234151, 205403633516427560050027271636224615375855, 727922215919878343821825296552148942903123, 1541646353685774868780093433673052445519807, 5703469721749658936787093922654529457118594, 20762100689139896330208273986505541316962105, 80195197197818086812949239946286778357513961, 198522126001869063688321920177617046841212852, 719060816608760633741229682178956301630549900, 2171712751463320729665634385979825928332317622, 7968526190188064156742281507099763347000210904, 20302513556821857703528100337806260797703562338, 54967103106163860243927426134510653397499429384, 189866376897538250029834405810321956080892995934, 516088075785491414669664215795496674103100750375, 1531616665488077085604100033058238685259376456655, 4795563798371064843556375420641263389159268373753, 12715206263244537077480789152826620386135239585589, 45628223673569886022145657218662773486560769778049, 127988774487590162169660910342623736153210927472871, 429761810968391607465089641939438991272623610573254, 1694286408402338132220805654166083638884822137745848, 5577419986858786911316434594350519553014729018524982, 22146179230778265190752372551893625479326089828877879, 78983119075073724439850825731329386811892547014513513, 165805826557531832743325076551678254671357810872202277, 525687524776397669648788242907896052104054917192402349, 1596680185629512867035574394423929715498386636216930988, 3808351509446054183279144714875260973968494634290203802, 10792542598439044383994436390450612942036864538927761344, 31776077718298264756461043701077481610506447838959767949, 69483787236434708634666641366101673156349500969799745632, 212620878051727200345257734337176214877612639791408110401, 565705372069455623425268706185184158331866127768259060570, 2228971348185635371906791535156337404926063871528397270892, 4859328204121938264839760465087547752629065763656619388434, 14185348803209161448182653444177464165713091554806223414499, 44242932119616103779840255273986809836494122475150635493273, 156176016196847319874949580221731690886061627436916661422852, 472567672907289753186461661432798790751774534772655287936877, 1765317440470718113352833182911767208733594355879647245836603, 5835719030771522391675663002032404790451900100534570526468736, 14528961633147270325279483890277955669830128461595478399405580, 53503137764341373520101774208921450303897226002280491351371881, 153340302591307960181257267214621247064964249027062324798966650, 467036429085212303265974827129085622046910166509299763268535756, 1760478013800716951650816419888923889893355872867499404847043361, 4791886951911545137378952129838133145784256723738609871941913863, 19126760116038883506408830737976498053029475253123685318001466609, 51635927378821965754946959553487670084314385367430813170544188707, 203944552994591250724882161307279862158139878326498083669171922709, 718868928147325949276701359623063723395455731358210896767864810436, 2005627527854915017699090052821431775394584514441537184407714355949, 6108484926321410509000933490330125849664844216966621898372849074206, 15273733259375332107091552084526951416159646708621190826219429490015, 34145117254940196604842578208457005181132408450899191627170638987883, 120825229084143066199868275091825674337472013226784591902132114229359, 387687667198606192147021527980207738864855944986764666796629571317797, 1461874344207808204456192497546273455901754164965322967295868406627707, 3258300231591322626530795072101331694347928535549768492906530809069244, 8874418273687545553519370439384854004509761935319681848589844232674343, 26555971104148502495508475192114409958713364020252024170586326291995544, 56653286369586527413345416396708661964062474995701742952261047069623359, 154383566127721041301459355493059400704799197964228029280865862358894596, 341393868848806018386217706353404785528207249510734290203621418976352706, 1171362524761660822765817023463786914069613269413196584856696440695273738, 4194882148022101614597714583113090146333385168895367467002069867303753334, 10081717223153632058965668126630772845024206141591578024505075742926631137, 39590555580101758090745061229221178837429140073072263518741551403983751377, 124978669991117804453179514660098523434116842472570073354436333226196401318, 285677744249355467333640461312079508294900634926466871637187648581093663108, 685643590088926190360498081484403342771108281930489395367499236756131358960, 2509513194338799699151211958956210034789618340347017416940796124375457114430, 7869725510782496795692771133398729561144872690341264618424961946628895219979]
l_list=[0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 0, 2, 1, 0, 1, 2, 1, 1, 1, 2, 0, 0, 2, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 2, 1, 0, 0, 1, 0, 1, 1, 1, 0, 2, 1, 3, 0, 2, 2, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 2, 0, 0, 1, 0, 1, 3, 0, 2, 0, 0, 1, 1, 3, 1, 2, 2, 1, 0, 0, 0, 2, 1, 1, 0, 0, 0, 1, 0, 1, 2, 1, 0, 1, 2, 0, 1, 3, 1, 0, 2, 2, 0, 1, 0, 1, 2, 1, 2, 3, 1, 0, 2, 1, 1, 2, 1, 2, 1, 0, 2, 0, 2, 2, 2, 1, 2, 1, 1, 1, 2, 3, 0, 1, 1, 2, 0, 1, 0, 0, 2, 2, 3, 2, 1, 2, 1, 1, 1, 3, 1, 0]
l_list=l_list[::-1]

for i in range(len(l_list)):
    flag=flag+l_list[i]*backpack[i]

print(long_to_bytes(flag))
```

>***FesitelTripple***
>>~~有点像DES，可惜不是，但是差不太多emmm~~
~~其实没太看懂，瞎改了一通反正跑出来了（bushi~~
DES里的加密和解密最后一轮是不会左右互换的，但是这里最后一轮还会互换，并且密钥依次用了keysteam里的16位
那么把range改成倒着来的，然后解密换成加密，加密换成解密就好了
``` python
from Crypto.Util.number import *
from Crypto.Cipher import AES


def encrypt(plaintext, keystream):
    assert len(plaintext) == 32
    assert len(keystream) == 48

    left = plaintext[:16]
    right = plaintext[16:]

    for i in range(2,-1,-1):
        
        aes = AES.new(keystream[i * 16:i * 16 + 16], AES.MODE_ECB)
        new_right = long_to_bytes(bytes_to_long(aes.encrypt(right)) ^ bytes_to_long(left))
        new_left = right
        left = new_left
        right = new_right
    return left + right


def decrypt(ciphertext, keystream):
    assert len(ciphertext) == 32
    assert len(keystream) == 48

    left = ciphertext[:16]
    right = ciphertext[16:]

    for i in range(2,-1,-1):
        
        aes = AES.new(keystream[i * 16:i * 16 + 16], AES.MODE_ECB)
        old_right = left
        old_left = long_to_bytes(bytes_to_long(right) ^ bytes_to_long(aes.encrypt(old_right)))
        left = old_left
        right = old_right

    return left + right


cipher=long_to_bytes(8465484536296110246056264738507061716988653458463168290845919961738127701895)
key1 = b'it_is_just_the_first_time_key_and_encrypt_twice~'
key2 = b'y0u can d0 what y0u w4nt t0 do!Go0d wishes~do it'

cipher = decrypt(cipher, key1)
cipher = encrypt(cipher, key2)
flag = decrypt(cipher, key1)

print(flag)
#moectf{th3_f3sit3l_1s_symmetric}
```
>>***NumberTheory-Powwwwwer***
>>>是RSA一种常见的攻击方式：共模攻击。
~~其实是网上嫖的代码QAQ~~

``` python
from Crypto.Util.number import *
import gmpy2
e1 = 0x114514
e2 = 11451401
n = 136101507305579392638535644920761633964164170724862786826983346232384615490056114520867809528578619044234996682189743771790469301482774597055261893015794231752161620186891313083697906603842794202124169703689691049507643124840305144271549786654248958903748746153284903228556081709492696702282014035715848536699

c1=47220438825147485602004110821622560065904207675219860468929327492230243119464967323930295623259686691976072363819976125368307866223981062386682077438030452670319556977872343275419275297828846355087444641575933688543206152050119271402939885941719672725566836549228027040543887994457719131600949478670978241146
c2=115435415972673976853578931507112950322194896557724940548983105717498084920603530063295392396344585245149536619546139549595643165285610305977637286040529163780201012187105549728000887169595946039777889559399483628995380569296124138575774025562472143420878790970785857061634021973901034670780393435693955936244

 
_, r, s = gmpy2.gcdext(e1, e2)
 
m = pow(c1, r, n) * pow(c2, s, n) % n
print(long_to_bytes(m))
#moectf{s0_Powwwwwwwwwwwww3r!}
```
> ***NumberTheory-MyGrandson***
>>其实比较明显，c比n小很多，而且e=3，属于是取模取了个寂寞。
而且不敢确定的话可以把c列表打出来看看，每个元素其实都是一样的，也就是说c列表里实际上都是m的三次方。那么我们把c直接开三次方就可以了。
不过pow函数有精度问题,所以用gmpy2.iroot开一下。
``` python
from Crypto.Util.number import*
import gmpy2

c=25681920037857462308038008456804236725305902130578298860433144085656782676411434281544156794249690534545397408244321828543334304937398521739382233631303709676426573143503446051379370337969083171791612381925477
m=gmpy2.iroot(c,3)
print(m)


#输出：(mpz(2950365559902224967742067902659102097834402066133060751891986702825853), True)


m=2950365559902224967742067902659102097834402066133060751891986702825853
print(long_to_bytes(m))
#moectf{Chinese_Remain_Theory}
```

## **Classical Cryptography**

> ***Augustine's Way***
>>npfdug{f3tz_Bv9v5u1of!}
就是凯撒，直接爆破。
moectf{e3sy_Au9u5t1ne!}

> ***OldButPopular***
>>凯撒＋栅栏，先凯撒，找首字母是m的，就是要找的字符串。
然后用在线网站解不太对，看一下长度发现是38，数一下moectf这几个字符的索引，发现分栏的方式应该是8 8 8 7 7，跟标准的栅栏密码稍微差那么一点 ~~，不然真成白给题了。~~

``` python
a="mf3n_u31o{rtg7_dec__0_w}c4wt_t0t540ohr"
a1=a[:8]
a2=a[8:16]
a3=a[16:24]
a4=a[24:31]
a5=a[31:]
flag=[]
for i in range(8):
    flag.append(a1[i])
    flag.append(a2[i])
    flag.append(a3[i])
    if i <7:
        flag.append(a4[i])
        flag.append(a5[i])
for i in flag:
    print(i,end="")
moectf{c453r_w4nt_t0_g0_ou7_th3_w0r1d}
```
> ***Augustine's Way#2***
>>凯撒变式，用ASCII码表做位移，不局限于字母了，所有字符都要位移。

``` python
cyber="eg][l^sdm(i)YfWqq\-u"
flag=[]
for i in cyber:
    flag.append(ord(i)+ord('m')-ord('e'))
for i in flag:
    print(chr(i),end='')
#moectf{lu0q1an_yyd5}
```
> ***Ez Vigenere***
>> 搜一下维吉尼亚，前几个字符对照moectf，可以知道密钥是rxyyds，拿去解密网站解密就好了
moectf{the_key_of_vigenere_is_rxyyds}

> ***モンスターを縫う！***
>> flag1，一眼凯撒，1位移：   **moectf{cl@**
flag2，维吉尼亚，密钥给了：  **ssical**
flag3，栅栏，密钥2：  **_cipher**
flag4，ABAAA，培根密码：  **I**
flag4，凯撒，13位移 ~~（我当时忽略那个B了，没想明白是啥意思，后来他们告诉我B拆开就是13······）~~ ：**pr3t**
flag5，摩斯密码： **tyg00d!｝**
**moectf{cl@ssical_cipherIpr3tyg00d!}**

> ***Ex Viginere?***
>> ~~重头戏终于来了~~
这个解密的详细过程在dbt的博客里有，我们只需要把他进行AES解密和base64解密的那一段删掉，然后就可以跑出来明文了。之后根据哈希值逐位爆破，找到flag。
简单来讲就是根据重合指数爆破出密钥长度，计算k1和k2，就可以还原明文。在足够长的英文文本中，每个字母出现的频率有一个确定的值，重合指数就是根据这一统计规律来计算的。
 ~~可以去看看dbt的博客，讲得可详细了\~~~

``` python
import gmpy2
f = open(r'c.txt','r')
c = f.read()
f.close()
# 我们已经知道，维吉尼亚密码可以被分解为若干组平移密码来破译，
# 而一个明文足够长的平移密码的重合指数接近 0.0687。
# 换言之，如果我们选取某个 l 值，使得分组后的密文的重合指数接近 0.065，
# 则说明选取的 t 值与密钥的长度是一致的。
best_index = 0.065
sum = 0
dic_index = {'a': 0.08167,'b': 0.01492,'c': 0.02782,'d':0.04253,'e': 0.12702,'f':0.02228,'g': 0.02015,'h':0.06094,'i':0.06966,'j':0.00153,'k':0.00772,'l':0.04025,'m':0.02406,'n':0.06749,'o':0.07507,'p':0.01929,'q':0.00095,'r':0.05987,'s':0.06327,'t':0.09056,'u':0.02758,'v':0.00978,'w':0.02360,'x':0.00150,'y':0.01974,'z':0.00074}
def IndCo(s):
    # 计算字符串的重合指数（所有字母出现频率的平方和）
    # 输入 s 
    # 输出 重合指数
    alpha = 'abcdefghijklmnopqrstuvwxyz'
    freq = {}
    for i in alpha:
        freq[i] = 0
    for i in s:
        freq[i] =  freq[i] + 1
    index = 0
    for i in alpha:
        index = index + (freq[i]*(freq[i] - 1 )) / (len(s) * (len(s) - 1 ))
    return index
def IndCo_m(s):
    # 计算明文 s 中的各字母频率和英文字母中的频率吻合程度
    # 输入：明文 s
    # 输出：吻合程度
    alpha = 'abcdefghijklmnopqrstuvwxyz'
    freq = {}
    for i in alpha:
        freq[i] = 0
    for i in s:
        freq[i] += 1
    index = 0
    for i in alpha:
        index += freq[i] / len(s) * dic_index[i]
    return index
def get_keylen(c):
    # 求出最符合统计学的 m,n 的最小公倍数，方法通过爆破足够大的周期样本，观察成倍出现的周期
    # 计算方法是解出每一个子密文段的重合指数然后求平均值 在和最佳重合指数相减 误差小于 0.01
    # 输入：密文
    # 输出：公共周期列表
    keylen = []
    for i in range(1,100):
        average_index = 0
        for j in range(i):
            s = ''.join(c[j+i*x] for x in range(0,len(c)//i))
            index = IndCo(s)
            average_index+=index
        average_index = average_index/i - best_index
        if abs(average_index)<0.01:
            keylen.append(i)
    return keylen
keylen = get_keylen(c)
print(keylen)
#____________________________得到 keylen_____________________________#
#____________________________爆破 flag———————————————————————————————#
def decrypt(c,i,j):
    alpha = 'abcdefghijklmnopqrstuvwxyz'
    m = ''
    for x in c:
        m += alpha[((alpha.index(x)-j)*gmpy2.invert(i,26))%26]
    return m 
def get_key(c):
    # 得到一个密文段的单个字符 key .i .j
    # 暴力枚举，找到最符合的
    # 输入：密文段
    # 输出：i,j
    for i in range(26):
        if gmpy2.gcd(i,26)!= 1 :
            continue
        for j in range(26):
            m = decrypt(c,i,j)
            index = IndCo_m(m)
            if abs(index-0.065)<0.01:
                return (i,j)
def get_all_key(s,keylen):
    # 得到一个周期内所有密文段的 key
    # 输入：原密文，周期
    # 输出：无
    for i in range(keylen):
        temps = ''.join([s[i+x*keylen] for x in range(0,len(s)//keylen)])
        print(get_key(temps))
get_all_key(c,keylen[0])
# 于是就可以分析得到 ka = []  kb= []
# 例如：(23, 9)(25, 21)(21, 9)(3, 10)(19, 16)(23, 3)(25, 22)(21, 13)(3, 14)(19, 21)(23, 15)(25, 9)(21, 21)(3, 9)(19, 10)(23, 16)(25, 3)(21, 22)(3, 13)(19, 14)(23, 21)(25, 15)(21, 9)(3, 21)(19, 9)(23, 10)(25, 16)(21, 3)(3, 22)(19, 13)(23, 14)(25, 21)(21, 15)(3, 9)(19, 21)(23, 9)(25, 10)(21, 16)(3, 3)(19, 22)(23, 13)(25, 14)(21, 21)(3, 15)(19, 9)(23, 21)(25, 9)(21, 10)(3, 16)(19, 3)(23, 22)(25, 13)(21, 14)(3, 21)(19, 15)
# 那么得到就是 k1=[23,25,21,3,19],k2=[9,21,9,10,16,3,22,13,14,21,15]
```

``` python
import gmpy2
from hashlib import*
k1=[9,7,25,11,11,19,5,3,25,9,7]
k2=[25,19,18,19,25,20,8]

f = open(r'c.txt','r')
c = f.read()
f.close()
plaintext = ''
l1 = len(k1)
l2 = len(k2)
alpha='abcdefghijklmnopqrstuvwxyz'
for i in range(len(c)):
    plaintext+=alpha[((alpha.index(c[i])-k2[i%l2])*gmpy2.invert(k1[i%l1],26))%26]

for i in range(len(plaintext)):
    a=plaintext[i:i+16]
    b=a+'How_Interesting_the_Cryptography_Is'
    if(md5(b.encode()).hexdigest()=='196cf7098c7ea6e3e4d03691fb9d4f58'):
        print(a)
#moectf{pieceofchocolate}
```

---

## **Reverse**

> ***welcome_to_the_world_of_re***
>> hex一下，拖到最后就有flag

> ***EinfachRe***

``` C
int main()
{
  int result; // eax
  char Destination[7]; // [esp+16h] [ebp-1Ah] BYREF
  char v[14]; // [esp+1Dh] [ebp-13h] BYREF
  char v3; // [esp+2Bh] [ebp-5h]
  int i; // [esp+2Ch] [ebp-4h]

  __main();
  strcpy(Destination, enflag);
  puts("Give me your flag:");
  gets(v);
  if ( check(v) )
  {
    for ( i = 0; i <= 6; ++i )
    {
      v3 = v[i] ^ v[i + 7];
      if ( v3 != Destination[i] )
      {
        puts("try again!!!");
        puts("your flag is moectf{******}");
        system("pause");
        return 0;
      }
    }
    printf("Congratulations!!!!!!!!!!!!!");
    system("pause");
    result = 0;
  }
  else
  {
    puts("wrong length!!");
    system("pause");
    result = 0;
  }
  return result;
}
```

>> 拖进IDA，F5看一下伪代码，大概意思就是把输入（flag）前7位跟后7位异或了一下，然后跟enflag比较，一致就正确。双击enflag跟进去看看，看到  _enflag         dd offset unk_406044
跟进去后面的地址，可以看到enflag的值,把这个值跟"moectf{"异或一下就能得到flag了

> ***Realezpy***
>> emmm下个uncompyle6就能反编译出来python代码了 ~~可以说是非常白给了~~

> ***A_game***
>> 拖到IDA里看一下伪代码，可以看到庆祝成功的一句话：Enjoy the beauty of reverse and sudoku!
~~英语学渣灵魂发问：这是让我享受逆向和啥玩意？？？~~
搜一下sudoku，发现是数独的意思，那这个题肯定跟数独有关了。
检查字符的时候有减48，就是字符'0'的ASCII码，所以我们输进去的应该是数字。
看一下3个check函数，发现都是9*9检验，应该是检查数独的函数吧。
跟进去box看一下:

```
.data:0000000000404020 box             db 2 dup(0), 5, 2 dup(0), 4, 3, 6, 5 dup(0), 5, 2 dup(0)
.data:0000000000404020                                         ; DATA XREF: check1+69↑o
.data:0000000000404020                                         ; check2+69↑o ...
.data:0000000000404020                 db 2, 4, 0, 4, 9, 6, 7, 4 dup(0), 1, 0, 6, 0, 2, 2 dup(0)
.data:0000000000404020                 db 3, 0, 9, 2 dup(0), 7, 2 dup(0), 1, 0, 8, 0, 3, 3 dup(0)
.data:0000000000404020                 db 5, 0, 9, 0, 2, 2 dup(0), 5, 0, 7, 2 dup(0), 9, 7, 0
.data:0000000000404020                 db 4, 3 dup(0), 8, 3 dup(0), 9, 2 dup(0), 4, 3 dup(0)
.data:0000000000404020                 db 6, 0Fh dup(0)
```

>> 一堆数字，还都是0~9之间的，合理怀疑这是数独的数组。还好之前学过一点汇编，知道 x dup(y)就是开辟x个空间，每个空间值为0，在这里应该就是空的意思了。
之后就简单多了，拿出笔和草稿纸，把数字填进去， ~~然后慢慢解数独吧~~
那是强者的解法，我~~这种懒得动脑子的彩笔~~还是找了个在线解数独的网站解出来，把所有数字输进程序里就有flag了。
这里注意一下，输完之后程序会闪退，所以在命令行里跑一下
~~我当时还傻不拉几的用OD单步调试看flag······~~

> ***clothes***
>> 开hint看了一下那个脱壳教程，简单来讲就是根据堆栈平衡原理，找pushad和popad的代码，把这段dump掉，然后拖到IDA里看伪代码就~~阳间多了~~很简单了，主要还是脱壳的过程。

> ***大佬请喝coffee***
>> ~~没什么好说的······打开我心爱的java~~
看一下代码，虽然没学过java，不过只要会c就不影响看代码（bushi）
没什么好说的，就是解非齐次线性方程组（大一小朋友或许可以看看线性代数？），扔到matlab里运算一通，然后打出来就行了······ ~~还是matlab好用~~
~~当时输错了一个数据，这题愣是看了一早上，永远忘不了······~~

> ***ez_Algorithm***
>> 当时做这个题的时候，好像是因为IDA版本不好，反汇编出来的伪代码根本不能看，后来换了个版本的IDA，当时那个做题场景应该是不能重现了emmm
~~就根据记忆和我留下的脚本简单说一下吧，反正是非预期\~bb听了都想锤我的那种~~
这个程序是炸空间的，因为不停地在递归。可以看到通过递归函数计算出一个值之后，跟一组数据异或一下然后输出flag。跟进去看一下这组数据，前几位比较小，可能因为递归的深度还比较小所以好计算，后面的数据都是八位的十六进制数据，前六位是两个数字轮替的，好像是E和5吧。
把前几个数据拿出来跟'moectf{'异或一下，得到一组数据，扔搜索引擎里搜一下，~~竟然真的有实现代码······~~

``` python
op = 1
step = 1
shuzu = [0]#这个数组的实现代码是网上嫖的，索引为平方数的元素就是找规律出来的元素
xor=[]
sq=[]

for i in range(76): 
    sq.append(i*i)


for i in range(5626):
    x += op * step
    op = -op
    step = step * 2
    shuzu.append(x)

for i in sq:
    test=str(hex(abs(shuzu[i])))
    print(test[-8:-1],end=',')
```

>>~~可以看到这个人可能跟我一样英语不太好~~
shuzu这个列表里索引为平方数的元素就是我们要找的数据，把它挑出来，但是因为后面的数据实在太大了，异或的话肯定不可能用这么大的数字。既然原本的数据都是8位，那我们把后8位的十六进制打出来看看就好了。
跑一下发现全是EEEEEEEE和55555555，那就把所有数据的后两位拿出来跟EE，55来回异或就可以了······

## **Misc**
> ***find_me***
>> hex一下，拖到最后就有flag

> ***Homework***
>> ~~我服了啊，我还开了hint，这题的hint是 “写作业字数凑不够怎么办啊啊啊啊啊啊啊啊啊啊TAT”，然后我以为是最后那段base6编码里有大量重复内容或者无意义的东西，找了好久，浪费好长时间······~~
解压缩之后一堆XML文件，直奔word文件里的document，flag就被分成一段一段的藏在里面，在<w:t>和</w:t>这两个标签里，慢慢找吧~

> ***Phone Call***
>> 扔AU里看一下频谱，然后在手机上打开拨号的声音，录一段，扔进AU里看一下频谱，对比一下两个频谱，慢慢找吧~
~~刚开始还想用我的辣鸡音感听一下来着，后来明白有的东西真的勉强不来\~~~

## **Pwn**

> ***test_your_nc***
>> 连一下靶场，cat flag就有了

> ***Int_overflow***
>> ~~其实我没看懂，我瞎搞的~~
胡乱输进去一大堆东西之后cat flag就有了（bushi）


~~总算写完了，累die~~